use crate::error::{MkunitError, Result};
use std::env;
use std::fs;
use std::path::{Path, PathBuf};

/// Marker comment to identify units created by mkunit
pub const MKUNIT_MARKER: &str = "# Generated by mkunit";

/// Unit types supported by mkunit
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum UnitType {
    Service,
    Timer,
    Path,
    Socket,
    Mount,
    Target,
}

impl UnitType {
    #[must_use]
    #[allow(clippy::trivially_copy_pass_by_ref)]
    pub fn extension(&self) -> &'static str {
        match self {
            Self::Service => "service",
            Self::Timer => "timer",
            Self::Path => "path",
            Self::Socket => "socket",
            Self::Mount => "mount",
            Self::Target => "target",
        }
    }

    #[must_use]
    pub fn from_extension(ext: &str) -> Option<Self> {
        match ext {
            "service" => Some(Self::Service),
            "timer" => Some(Self::Timer),
            "path" => Some(Self::Path),
            "socket" => Some(Self::Socket),
            "mount" => Some(Self::Mount),
            "target" => Some(Self::Target),
            _ => None,
        }
    }
}

impl std::fmt::Display for UnitType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.extension())
    }
}

/// Get the user's systemd unit directory
pub fn user_unit_dir() -> Result<PathBuf> {
    let home = env::var("HOME")
        .map_err(|_| MkunitError::Other("HOME environment variable not set".to_string()))?;

    let path = PathBuf::from(home)
        .join(".config")
        .join("systemd")
        .join("user");

    Ok(path)
}

/// Get the system unit directory
#[must_use]
pub fn system_unit_dir() -> PathBuf {
    PathBuf::from("/etc/systemd/system")
}

/// Get the appropriate unit directory based on system flag
pub fn unit_dir(system: bool) -> Result<PathBuf> {
    if system {
        Ok(system_unit_dir())
    } else {
        user_unit_dir()
    }
}

/// Get the full path for a unit file
pub fn unit_path(name: &str, unit_type: UnitType, system: bool) -> Result<PathBuf> {
    let dir = unit_dir(system)?;
    let filename = if name.ends_with(&format!(".{}", unit_type.extension())) {
        name.to_string()
    } else {
        format!("{}.{}", name, unit_type.extension())
    };
    Ok(dir.join(filename))
}

/// Get the full path for any unit file (auto-detect type from name)
#[allow(dead_code)]
pub fn unit_path_any(name: &str, system: bool) -> Result<PathBuf> {
    let dir = unit_dir(system)?;

    // Check if name already has an extension
    if let Some(ext) = name.rsplit('.').next() {
        if UnitType::from_extension(ext).is_some() {
            return Ok(dir.join(name));
        }
    }

    // Try common extensions
    for unit_type in &[
        UnitType::Service,
        UnitType::Timer,
        UnitType::Path,
        UnitType::Socket,
        UnitType::Mount,
        UnitType::Target,
    ] {
        let path = dir.join(format!("{}.{}", name, unit_type.extension()));
        if path.exists() {
            return Ok(path);
        }
    }

    // Default to service
    Ok(dir.join(format!("{name}.service")))
}

/// Find a unit file, searching both user and system directories
pub fn find_unit(name: &str, system: bool) -> Result<PathBuf> {
    let mut searched = Vec::new();

    // Search in the specified scope first
    let primary_dir = unit_dir(system)?;
    let path = find_unit_in_dir(name, &primary_dir);
    searched.push(path.clone().unwrap_or_else(|| primary_dir.join(name)));

    if let Some(p) = path {
        if p.exists() {
            return Ok(p);
        }
    }

    // Build hint based on what we searched
    let hint = if system {
        "Use --user flag for user units"
    } else {
        "Use --system flag for system units"
    };

    Err(MkunitError::unit_not_found_with_hint(name, searched, hint))
}

/// Find a unit file in a specific directory
fn find_unit_in_dir(name: &str, dir: &Path) -> Option<PathBuf> {
    // Check if name already has an extension
    if let Some(ext) = name.rsplit('.').next() {
        if UnitType::from_extension(ext).is_some() {
            let path = dir.join(name);
            if path.exists() {
                return Some(path);
            }
        }
    }

    // Try common extensions
    for unit_type in &[
        UnitType::Service,
        UnitType::Timer,
        UnitType::Path,
        UnitType::Socket,
        UnitType::Mount,
        UnitType::Target,
    ] {
        let path = dir.join(format!("{}.{}", name, unit_type.extension()));
        if path.exists() {
            return Some(path);
        }
    }

    None
}

/// Ensure the unit directory exists
#[allow(dead_code)]
pub fn ensure_unit_dir(system: bool) -> Result<PathBuf> {
    let dir = unit_dir(system)?;
    fs::create_dir_all(&dir)?;
    Ok(dir)
}

/// List all units in a directory
pub fn list_units(system: bool) -> Result<Vec<PathBuf>> {
    let dir = unit_dir(system)?;

    if !dir.exists() {
        return Ok(Vec::new());
    }

    let mut units = Vec::new();
    for entry in fs::read_dir(&dir)? {
        let entry = entry?;
        let path = entry.path();
        if let Some(ext) = path.extension().and_then(|e| e.to_str()) {
            if UnitType::from_extension(ext).is_some() {
                units.push(path);
            }
        }
    }

    units.sort();
    Ok(units)
}

/// Check if a unit was created by mkunit
pub fn is_mkunit_created(path: &PathBuf) -> bool {
    fs::read_to_string(path)
        .map(|content| content.contains(MKUNIT_MARKER))
        .unwrap_or(false)
}

/// Get the unit name from a path
#[must_use]
pub fn unit_name_from_path(path: &Path) -> Option<String> {
    path.file_name().and_then(|n| n.to_str()).map(String::from)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_unit_type_extension() {
        assert_eq!(UnitType::Service.extension(), "service");
        assert_eq!(UnitType::Timer.extension(), "timer");
        assert_eq!(UnitType::Path.extension(), "path");
    }

    #[test]
    fn test_unit_type_from_extension() {
        assert_eq!(UnitType::from_extension("service"), Some(UnitType::Service));
        assert_eq!(UnitType::from_extension("timer"), Some(UnitType::Timer));
        assert_eq!(UnitType::from_extension("invalid"), None);
    }

    #[test]
    fn test_system_unit_dir() {
        assert_eq!(system_unit_dir(), PathBuf::from("/etc/systemd/system"));
    }
}
